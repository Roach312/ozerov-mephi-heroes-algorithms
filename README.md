## Реализованные алгоритмы

### 1. UnitTargetPathFinderImpl — Поиск кратчайшего пути

**Алгоритм:** BFS (Breadth-First Search) — поиск в ширину

**Описание:**  
Алгоритм находит кратчайший путь между атакующим и атакуемым юнитом на игровом поле размером 27×21 клеток. Поддерживается движение в 8 направлениях (включая диагонали).

**Структуры данных:**
- `Set<String>` — множество препятствий (занятые клетки)
- `Queue<int[]>` — очередь BFS для обхода клеток
- `Map<String, int[]>` — карта родителей для восстановления пути

**Почему BFS:**  
Все рёбра графа имеют одинаковый вес (1 клетка), поэтому BFS гарантирует нахождение кратчайшего пути. Алгоритм Дейкстры или A* не дают преимущества при равных весах рёбер.

**Алгоритмическая сложность:**
- **Временная:** O(V + E), где V = WIDTH × HEIGHT = 27 × 21 = 567 вершин
- Каждая вершина посещается один раз, для каждой проверяется до 8 соседей
- E ≤ 8V, поэтому O(V + E) = O(9V) = **O(WIDTH × HEIGHT)**
- Требуемая сложность: O((W×H) log(W×H)) — выполнено с запасом

---

### 2. SuitableForAttackUnitsFinderImpl — Поиск атакуемых юнитов

**Алгоритм:** Линейный проход с поиском крайних юнитов

**Описание:**  
Алгоритм определяет, какие юниты противника доступны для атаки. Юнит подходит для атаки, если он является крайним в своём ряду (не заблокирован другими юнитами своей армии).

**Логика блокировки:**
- При атаке на левую армию (`isLeftArmyTarget = true`): подходят юниты с **минимальной** y-координатой в каждом ряду (не закрыты слева)
- При атаке на правую армию (`isLeftArmyTarget = false`): подходят юниты с **максимальной** y-координатой в каждом ряду (не закрыты справа)

**Оптимизация:**  
Вместо проверки всех пар юнитов O(n²), используем два прохода:
1. Первый проход — находим крайнее значение y (min или max)
2. Второй проход — собираем всех юнитов с этим значением y

**Структуры данных:**
- `List<List<Unit>>` — юниты, сгруппированные по рядам (по x-координате)
- `List<Unit>` — результирующий список подходящих юнитов

**Алгоритмическая сложность:**
- **Временная:** O(n × m), где n — юнитов в ряду, m — количество рядов
- Внешний цикл: m = 3 итерации (фиксировано)
- Два внутренних прохода по ряду: O(n) + O(n) = O(n)
- Итого: O(m × n) = **O(n)** при фиксированном m = 3
- Требуемая сложность: O(n × m) — выполнено

---

### 3. GeneratePresetImpl — Генерация армии компьютера

**Алгоритм:** Жадный (Greedy Algorithm)

**Описание:**  
Алгоритм формирует оптимальную армию компьютера, максимизируя боевую эффективность в рамках бюджета очков.

**Критерии оптимизации (в порядке приоритета):**
1. Соотношение атаки к стоимости: `attack / cost`
2. Соотношение здоровья к стоимости: `health / cost`

**Ограничения:**
- Максимум 11 юнитов каждого типа
- Суммарная стоимость ≤ maxPoints (1500)

**Структуры данных:**
- `List<Unit>` — отсортированный список типов юнитов
- `Map<String, Integer>` — счётчик юнитов по типам
- `List<Unit>` — результирующая армия

**Алгоритмическая сложность:**
- **Сортировка:** O(n log n), где n = 4 типа юнитов
- **Жадное заполнение:** O(n × m), где m — максимальное число юнитов в армии
- На каждой итерации проходим по отсортированному списку типов и добавляем один юнит
- Максимум итераций: m = 11 × 4 = 44 (по 11 юнитов каждого из 4 типов)
- Итого: O(n log n + n × m) = **O(n × m)**
- Требуемая сложность: O(n × m) — выполнено

---

### 4. SimulateBattleImpl — Симуляция боя

**Алгоритм:** Итеративная симуляция с приоритетной очередью

**Описание:**  
Алгоритм проводит пошаговую симуляцию боя между армией игрока и армией компьютера.

**Правила симуляции:**
1. В начале каждого раунда все живые юниты собираются в общую очередь
2. Очередь сортируется по убыванию значения атаки
3. Юниты ходят по очереди, вызывая метод `attack()` своей программы
4. Погибшие юниты пропускают ход
5. После атаки выводится лог через `printBattleLog`
6. Бой завершается, когда у одной армии не остаётся живых юнитов

**Структуры данных:**
- `List<Unit>` — очередь ходов текущего раунда

**Алгоритмическая сложность:**
- **Один раунд:**
  - Сбор живых юнитов: O(n)
  - Сортировка: O(n log n)
  - Выполнение ходов: O(n) (при условии, что `attack()` работает за O(1))
  - Итого за раунд: O(n log n)
- **Количество раундов:** В худшем случае O(n), если каждый раунд погибает один юнит
- **Общая сложность:** O(n) × O(n log n) = **O(n² log n)**
- Требуемая сложность: O(n² log n) — выполнено

---
